module eclipse.emf.Design

import eclipse.emf.dsl.Editor


/* This model explains the essential design patterns
used. At a very upper level we have an MVC design pattern.
The view is tightly coupled with Eclipse's JFace that provides an API
for Eclipse views, i.e., JFace. More of this is discussed in Editor.megal */
Emf uses Model-View-Controller.
?DslModelPlugin hasRole MvcModel.
?DslEditPlugin hasRole MvcController.
?DslEditorPlugin hasRole MvcView;
    reuses JFace.


/* The Adapter pattern is present in the EMF implementation and is 
presumably hard to grasp. http://www.eclipse.org/forums/index.php?t=msg&th=129825/ 
We reverse engineered the design and came to the following identification
of participants.
First we can identify the abstract classes for important roles. */
?DslEditorCode hasRole AdapterClient. //One accesses the adapters through the factory??
AdapterInterface : Artifact;
    = "org.eclipse.emf.common.notify.Adapter";
    elementOf Java;
    hasRole Interface;
    hasRole AbstractAdapter;
    manifestsAs File;
    partOf EmfCorePlugin.
Notifier : Artifact;
    = "org.eclipse.emf.common.notify.Notifier"; //This would rather be EObject
    elementOf Java;
    hasRole Interface;
    hasRole AbstractAdaptee;
    manifestsAs File;
    partOf EmfCorePlugin.

/* For every model class in the model, there exists an item provider.
The item provider implementations for each model class extend 
the class ItemProviderAdapter that is actually complicated with about 3000+ LoC. */
?DslItemProvider : Artifact;
    hasRole Adapter;
    hasRole MvcController;
    hasRole Observer;   //Pure guess
    hasRole ObserverSubject. //Verified this one
?dslJvmObject hasRole Adaptee;
    hasRole MvcModel.
?dslEditor hasRole AdapterClient;
    hasRole MvcView.

/* Actually the next thing is shown here: http://help.eclipse.org/neon/topic/org.eclipse.emf.doc/references/overview/images/EMF.Edit/image007.gif
This is what makes it hard to get. This one single class has many jobs at once. 
When something is read, the adapter actually implements interfaces to retrieve content and label information
When the editor writes something, the adapter implements interfaces to create and "push" commands to 
edit the model through the AdapterFactory.
 */

    
/* We discuss evidence for an Observer Pattern next. */
?DslEObject hasRole ObserverSubject;
?ItemProviderAdapter hasRole ObserverObject;


/* The Command Pattern is also used to redo and undo operations */
ItemProviderAdapter hasRole CommandCaller



AbstractFactoryPattern

AbstractFactory 
AbstractProduct

Template Method design pattern





