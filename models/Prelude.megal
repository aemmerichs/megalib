Language < Entity
ProgrammingLanguage < Language
DataRepresentationLanguage < Language // Any binding?
MarkupLanguage < Language
TransformationLanguage < Language
QueryLanguage < Language 
NaturalLanguage < Language // Aren't we talking about just software languages?
elementOf < Artifact # Language
subsetOf < Language # Language

English : NaturalLanguage
String : DataRepresentationLanguage
Number : DataRepresentationLanguage
Boolean : DataRepresentationLanguage

Artifact < Entity
// Purpose-based classification of artifacts
SyntaxDefinition < Artifact
Grammar < ???
Metamodel < ???
Model < ???
Specification < Artifact
Value < Artifact
Configuration < Artifact

defines < Artifact # Entity // Too general?
conformsTo < Artifact # Artifact
correspondsTo < Artifact # Artifact

// Manifestations of artifacts
Manifestation < Entity
File : Manifestation
File = "https://en.wikipedia.org/wiki/Computer_file"
File+ : Manifestation
File+ = "https://en.wikipedia.org/wiki/Computer_file"
Folder : Manifestation
Folder = "https://en.wikipedia.org/wiki/Directory_(computing)"
WebResource : Manifestation
WebResource = "https://en.wikipedia.org/wiki/Web_resource"
Transient : Manifestation
Transient = "https://en.wikipedia.org/wiki/Transient_(computer_programming)"
Fragment : Manifestation
Fragment = "https://en.wikipedia.org/wiki/Snippet_(programming)"
manifestsAs < Artifact # Manifestation

// Roles of artifacts
Role < Entity
Grammar : Role
Database : Role
Schema : Role
Query : Role
Model : Role // in the sense of MDE
Metamodel : Role // in the sense of MDE
MvcModel : Role
MvcView : Role
MvcController : Role
hasRole < Artifact # Role
participantOf < Role # DesignPattern
participantOf < Role # ArchitecturalStyle
participantOf??? < Role # ProgrammingDomain // Better name needed

Function < Entity
Transformation < Function
implements < Artifact # Function

// Classification of technologies
Technology < Entity
API < Technology
Library < Technology
Framework < Technology
System < Entity
Application < System
WebApplication < System

// Part-of relationships
partOf < Artifact # Artifact
partOf < Artifact # System
partOf < Artifact # Technology
partOf < Technology # Technology
partOf < System # System

// Implementation relationships
implements < Artifact # Function
implements < Technology # Function
implements < Technology # Language
implements < System # Function

// We should eventually replace Concept by more specific categories.
Concept < Entity
Paradigm < Concept // Maybe we should derive from Entity directly
ProgrammingDomain < Concept
TechnologySpace < Concept
DesignPattern < Concept
ArchitecturalStyle < Concept
AbstractProcess < Concept // Name?
XMLSerialization : AbstractProcess

belongsTo < Technology # ProgrammingDomain // should that be "supports"
realizes < Artifact # AbstractProcess
realizes < Technology # AbstractProcess

// Usage
uses < System # System
uses < System # Technology
uses < System # DesignPattern
uses < System # ArchitecturalStyle
uses < System # AbstractProcess
uses < System # Language
uses < Technology # Technology
uses < Technology # DesignPattern
uses < Technology # ArchitecturalStyle
uses < Technology # Language
uses < Artifact # DesignPattern
uses < Artifact # ArchitecturalStyle
uses < Artifact # System
uses < Artifact # Technology
uses < Artifact # Language

// Facilitation ("deferred" usage)
facilitates < Technology # DesignPattern
facilitates < Technology # ArchitecturalStyle
facilitates < Technology # ProgrammingDomain // Should we add this one?
facilitates < Technology # AbstractProcess
facilitates < Language # Paradigm
facilitates < Language # ProgrammingDomain
